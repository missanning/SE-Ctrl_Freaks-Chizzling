# Documentation
Sprint summary: In our first sprint, our team completed the core "Must-have" features designed to transition Chizzling from manual to digital operations. In our ticketing system, we closed out US-01: Digital Transaction Processing and US-02: Receipt After Sale. These features allow our cashiers to process sales with automatic calculations and generate e-receipts for customers. We also implemented a secure login system for the owner, a sales dashboard for monitoring profitability, and a product management module to keep the digital menu up to date. During this process, we encountered several challenges, particularly regarding technical and resource constraints. Since we have no allocated budget, we relied entirely on free tools like Python and SQLite, which required us to be very intentional about database optimization to avoid lag. Additionally, our schedule constraints limited our full-team collaboration making communication efficiency vital. In the next sprint, we plan to improve our performance optimization and begin implementing "Should-have" features, such as restock suggestions and profitability reports, to give the owner better insights into the business.

The system incorporates several important security considerations to minimize potential vulnerabilities. One major security risk exists in database queries, particularly in the login system and in all database operations that involve user input. This risk is commonly associated with SQL injection attacks, where malicious users attempt to insert harmful SQL code through input fields. To address this issue, the system consistently uses parameterized queries with placeholders (?) instead of directly concatenating user inputs into SQL statements. By passing user inputs as parameters, the database treats them strictly as data rather than executable code, significantly reducing the risk of unauthorized database manipulation and strengthening overall system security.

Another identified security concern is the storage of user passwords in plain text within the database. Although this approach functions for development purposes, it presents a vulnerability if the database file is accessed by unauthorized individuals. To minimize exposure, the password input field in the login interface is masked using show="*", ensuring that passwords are hidden during entry. Additionally, the database file is excluded from version control through the .gitignore file to prevent accidental credential exposure. However, for production-level deployment, implementing password hashing using libraries such as bcrypt or hashlib would be necessary to ensure stronger protection.

The system follows established coding standards to maintain readability, consistency, and maintainability. It adheres to the PEP 8 Python Style Guide by using PascalCase for class names and snake_case for functions and variables. The code maintains consistent four-space indentation, proper spacing between logical sections, and descriptive inline comments to clarify different UI components and processes. These practices enhance clarity and make the code easier to understand and modify.

Object-Oriented Programming (OOP) principles are applied throughout the system. Encapsulation is demonstrated by grouping related data and methods within their respective classes, such as the login and POS classes. Each class follows the Single Responsibility Principle, ensuring that it performs one specific function within the system. Database connection logic is centralized in a reusable function to avoid code duplication, following the DRY (Don’t Repeat Yourself) principle. Defensive programming techniques are also implemented, including try-except blocks for handling user input errors, validation checks before completing transactions, and user-friendly error messages to guide users when issues occur.

One of the strongest aspects of the system is its proper separation of concerns using an MVC-like structure. The code clearly separates the presentation layer, which consists of the UI widgets built using Tkinter, the business logic responsible for transaction processing, and the data access layer that handles database operations. Receipt generation is modularized in a separate file (receipt_module.py), while database setup and initialization are isolated in setup_database.py. This modular structure makes the code easier to maintain, test, debug, and extend in the future. Additionally, the overall codebase is well organized and follows a clean and readable structure, which supports long-term scalability and maintainability.

While the system functions correctly, input validation and error handling can still be improved. The current implementation includes only minimal validation checks. Strengthening validation rules, improving error handling mechanisms, and implementing more secure authentication practices would enhance the system’s overall reliability. These improvements would make the system more secure, stable, and production-ready.

Several valuable lessons were learned during the implementation process. Using proper table relationships and foreign keys made transaction tracking more reliable and ensured data integrity across records. Careful database planning simplifies future expansion and improves reporting capabilities. Separating the receipt module from the main POS system allowed independent testing and easier feature additions without affecting core functionality. Additionally, programming the login system was manageable because Tkinter had already been introduced during the first year. Having prior knowledge of the framework helped speed up development and made the implementation process more efficient.
